" ============================================
" リーダーキー設定
" ============================================
let mapleader = " "  " スペースキーをleaderに設定

" ============================================
" Python
" ============================================
let g:python3_host_prog = trim(system('uv python find'))

" ============================================
" カラースキーム
" ============================================
syntax on
set background=dark
set t_Co=256
set termguicolors
let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
colorscheme gruvbox

" ============================================
" GraphQL / Denops設定
" ============================================
" neovim を 0.10.0 以上にあげたらいらなくなる記述
let g:denops_disable_version_check = 1

" ============================================
" Airline - ステータスライン・タブライン
" ============================================
" タブラインの表示設定
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#show_buffers = 0
let g:airline#extensions#tabline#show_splits = 0
let g:airline#extensions#tabline#show_tabs = 1
let g:airline#extensions#tabline#show_tab_nr = 0
let g:airline#extensions#tabline#show_tab_type = 0
let g:airline#extensions#tabline#close_symbol = '×'
let g:airline#extensions#tabline#show_close_button = 0
let g:airline#extensions#tabline#formatter = 'unique_tail'
let g:airline#extensions#virtualenv#enabled = 1
let g:airline_theme = 'base16_gruvbox_dark_hard'
let g:airline#extensions#default#layout = [
    \ [ 'z', 'y', 'x' ],
    \ [ 'c', 'b', 'a', 'error', 'warning']
    \ ]
if !exists('g:airline_symbols')
  let g:airline_symbols = {}
endif

" 使い方:
"   <Tab>           : 前のタブに移動
"   <Shift-Tab>     : 次のタブに移動
"   <Ctrl-c>        : 新しいタブを開く
nmap <Tab> <Plug>AirlineSelectPrevTab
nmap <S-Tab> <Plug>AirlineSelectNextTab
nmap <C-c> :tablast <bar> tabnew<CR>

" ============================================
" eslint - 自動修正
" ============================================
" TypeScript/JavaScript保存時に自動でeslint --fixを実行
autocmd BufWritePre *.tsx,*.ts,*.jsx,*.js EslintFixAll

" ============================================
" vim-gitgutter - Git差分表示
" ============================================
set signcolumn=yes

" ============================================
" toggleterm.nvim - ターミナルウィンドウ管理
" ============================================
" 使い方:
"   <Ctrl-t>        : ターミナルをトグル（表示/非表示）
"   ターミナル内で:
"     jk            : ノーマルモードに切り替え（jとkを素早く連続で押す）
"     i or a        : インサートモードに戻る
"     <Ctrl-t>      : ターミナルを閉じる
"
" Oxker (Docker TUI) の使い方:
"   ターミナルを開いて、以下のコマンドを実行:
"     oxker         : Dockerコンテナ管理TUIを起動
"   Oxker内で:
"     ↑↓            : コンテナ選択
"     e             : コンテナのシェルに入る (docker exec)
"     l             : ログを表示
"     s             : コンテナの開始/停止
"     r             : コンテナの再起動
"     d             : コンテナの削除
"     ?             : ヘルプを表示
"     q             : 終了
lua <<EOF
local status_ok, toggleterm = pcall(require, "toggleterm")
if status_ok then
  toggleterm.setup({
    size = 100,
    open_mapping = [[<c-t>]],
    direction = 'float',  -- フローティングウィンドウとして表示
    start_in_insert = true,
    float_opts = {
      border = 'curved',
      winblend = 0,
    },
    on_open = function(term)
      vim.opt_local.number = true
      vim.opt_local.relativenumber = false
    end,
  })

  -- lazygit 専用のターミナルを作成
  local Terminal = require('toggleterm.terminal').Terminal
  local lazygit = Terminal:new({
    cmd = "lazygit",
    hidden = true,
    direction = "float",
    float_opts = {
      border = "curved",
    },
    on_open = function(term)
      vim.cmd("startinsert!")
    end,
  })

  function _lazygit_toggle()
    lazygit:toggle()
  end
end
EOF

" ============================================
" lazygit - Git TUI (toggleterm経由)
" ============================================
" 使い方:
"   <leader>g       : Lazygitを起動
"   Lazygit内で:
"     ?             : ヘルプを表示
"     q             : 終了
"     <Space>       : ファイルをステージング/アンステージング
"     c             : コミット
"     P             : プッシュ
"     p             : プル
"     [             : 前のタブ
"     ]             : 次のタブ
nnoremap <silent> <leader>g :<C-u>lua _lazygit_toggle()<CR>

" ============================================
" diffview.nvim - Diff表示とマージエディタ
" ============================================
" 使い方:
"   <leader>df      : DiffViewを開く
"   :DiffviewClose  : DiffViewを閉じる
"   DiffView内で:
"     ]c / [c       : 次/前の変更箇所へジャンプ
"     <leader>co    : OURS側を採用（コンフリクト解決時）
"     <leader>ct    : THEIRS側を採用（コンフリクト解決時）
"     <leader>cb    : BASE側を採用（コンフリクト解決時）
"     <leader>ca    : 全ての変更を採用（コンフリクト解決時）
lua <<EOF
local status_ok, diffview = pcall(require, "diffview")
if status_ok then
  diffview.setup({
    enhanced_diff_hl = true,
  })
end
EOF
nnoremap <silent> <leader>df :<C-u>DiffviewOpen<CR>

" ============================================
" terminal - 組み込みターミナル設定
" ============================================
" 使い方:
"   :T <command>    : 下部に分割してターミナルを開く
"   ターミナル内で:
"     jk            : ノーマルモードに切り替え（jとkを素早く連続で押す）
"                     ※ネストされたNeovim内で:wqなどを使えるようにするため
tnoremap jk <C-\><C-n>
command! -nargs=* T split | wincmd j | resize 20 | terminal <args>
autocmd TermOpen * startinsert

" ============================================
" fzf-preview.vim - ファジーファインダー
" ============================================
" 使い方:
"   <Ctrl-p>        : プロジェクト内のファイルを検索
"   gs              : Git statusのファイルを検索
"   gl              : Gitログを表示
"   ga              : Git actionsメニュー
"   gr <keyword>    : プロジェクト内をgrep検索
"   ビジュアルモードで gr : 選択したテキストをgrep検索
"   検索結果内で:
"     <Ctrl-o>      : ファイルを開く
"     <Ctrl-t>      : 新しいタブで開く
"     <Ctrl-v>      : 縦分割で開く
"     <Ctrl-x>      : 横分割で開く
"     <Ctrl-a>      : すべて選択/解除をトグル
nnoremap <silent> <C-p>  :<C-u>FzfPreviewProjectFilesRpc<CR>
nnoremap <silent> gs  :<C-u>FzfPreviewGitStatusRpc<CR>
nnoremap <silent> gl  :<C-u>FzfPreviewGitLogsRpc<CR>
nnoremap <silent> ga  :<C-u>FzfPreviewGitActionsRpc<CR>
nnoremap <silent> gr  :<C-u>FzfPreviewProjectGrepRpc --add-fzf-arg=--exact --add-fzf-arg=--no-sort<Space>
xnoremap gr  "sy:FzfPreviewProjectGrepRpc --add-fzf-arg=--exact --add-fzf-arg=--no-sort<Space>-F<Space>"<C-r>=substitute(substitute(@s, '\n', '', 'g'), '/', '\\/', 'g')<CR>"

let g:fzf_preview_custom_processes = {
            \ 'open-file': {
            \     'ctrl-o': 'FzfPreviewOpenFileCtrlO',
            \     'ctrl-f': 'FzfPreviewOpenFileCtrlQ',
            \     'ctrl-t': 'FzfPreviewOpenFileCtrlT',
            \     'ctrl-v': 'FzfPreviewOpenFileCtrlV',
            \     'ctrl-x': 'FzfPreviewOpenFileCtrlX',
            \     'enter': 'FzfPreviewOpenFileEnter'
            \ },
            \ 'register': {
            \     'enter': 'FzfPreviewRegisterEnter'
            \ }
\ }
let $FZF_DEFAULT_OPTS=$FZF_DEFAULT_OPTS . ' --bind "ctrl-a:toggle-all"'

" 折り畳みを無効にする
set nofoldenable

" ============================================
" fern.vim - ファイルエクスプローラー
" ============================================
" 使い方:
"   <Ctrl-n>        : ファイルツリーをトグル（サイドバー表示/非表示）
"   ファイルツリー内で:
"     <Enter>       : ファイルを開く/ディレクトリを展開
"     l             : ディレクトリを展開
"     h             : ディレクトリを閉じる
"     R             : ツリーを更新
"     N             : 新しいファイルを作成
"     K             : 新しいディレクトリを作成
"     D             : ファイル/ディレクトリを削除
"     r             : ファイル/ディレクトリをリネーム
"     .             : 隠しファイルの表示/非表示
let g:fern#default_hidden=1
let g:fern#renderer = 'nerdfont'
nnoremap <C-n> :Fern . -reveal=% -drawer -toggle -width=40<CR>

" ============================================
" nvim-cmp, nvim-lspconfig - 補完とLSP設定
" ============================================
" 環境変数設定
" 各言語環境のPATH設定（統一フォーマット: shims → versions/bin）
let $PATH = ''
      \ . $HOME . '/.rbenv/shims:'
      \ . $HOME . '/.rbenv/versions/{{ ruby_version }}/bin:'
      \ . $HOME . '/.goenv/shims:'
      \ . $HOME . '/go/{{ go_version }}/bin:'
      \ . $HOME . '/.local/bin:'
      \ . $HOME . '/.nodenv/shims:'
      \ . $PATH
let $NODENV_VERSION = '{{ node_version }}'
let $GOENV_VERSION = '{{ go_version }}'
let $RBENV_VERSION = '{{ ruby_version }}'
set completeopt=menu,menuone,noselect

lua <<EOF
  -- ============================================
  -- LSP グローバルキーマップ
  -- ============================================
  -- 使い方:
  --   <Space>e      : 診断メッセージをフロートで表示
  --   [d            : 前の診断へ移動
  --   ]d            : 次の診断へ移動
  --   <Space>q      : 診断リストを表示
  vim.keymap.set('n', '<space>e', vim.diagnostic.open_float)
  vim.keymap.set('n', '[d', vim.diagnostic.goto_prev)
  vim.keymap.set('n', ']d', vim.diagnostic.goto_next)
  vim.keymap.set('n', '<space>q', vim.diagnostic.setloclist)

  -- ============================================
  -- LSP バッファ固有のキーマップ
  -- ============================================
  -- LSPがアタッチされたバッファでのみ有効になるキーマップ
  -- 使い方:
  --   gD            : 宣言へジャンプ
  --   gd            : 定義へジャンプ
  --   K             : ホバー情報を表示（ドキュメント）
  --   gi            : 実装へジャンプ
  --   <Ctrl-m>      : 関数シグネチャのヘルプを表示
  --   <Space>wa     : ワークスペースフォルダを追加
  --   <Space>wr     : ワークスペースフォルダを削除
  --   <Space>wl     : ワークスペースフォルダ一覧を表示
  --   <Space>D      : 型定義へジャンプ
  --   <Space>rn     : シンボルをリネーム
  --   <Space>ca     : コードアクション（クイックフィックス）
  --   gr            : 参照を検索
  --   <Space>f      : コードフォーマット
  vim.api.nvim_create_autocmd('LspAttach', {
    group = vim.api.nvim_create_augroup('UserLspConfig', {}),
    callback = function(ev)
      vim.bo[ev.buf].omnifunc = 'v:lua.vim.lsp.omnifunc'

      local opts = { buffer = ev.buf }
      vim.keymap.set('n', 'gD', vim.lsp.buf.declaration, opts)
      vim.keymap.set('n', 'gd', vim.lsp.buf.definition, opts)
      vim.keymap.set('n', 'K', vim.lsp.buf.hover, opts)
      vim.keymap.set('n', 'gi', vim.lsp.buf.implementation, opts)
      vim.keymap.set('n', '<C-m>', vim.lsp.buf.signature_help, opts)
      vim.keymap.set('n', '<space>wa', vim.lsp.buf.add_workspace_folder, opts)
      vim.keymap.set('n', '<space>wr', vim.lsp.buf.remove_workspace_folder, opts)
      vim.keymap.set('n', '<space>wl', function()
        print(vim.inspect(vim.lsp.buf.list_workspace_folders()))
      end, opts)
      vim.keymap.set('n', '<space>D', vim.lsp.buf.type_definition, opts)
      vim.keymap.set('n', '<space>rn', vim.lsp.buf.rename, opts)
      vim.keymap.set({ 'n', 'v' }, '<space>ca', vim.lsp.buf.code_action, opts)
      vim.keymap.set('n', 'gr', vim.lsp.buf.references, opts)
      vim.keymap.set('n', '<space>f', function()
        vim.lsp.buf.format { async = true }
      end, opts)
    end,
  })

  -- ============================================
  -- nvim-cmp 補完設定
  -- ============================================
  -- 使い方:
  --   <Ctrl-b>      : 補完ドキュメントを上にスクロール
  --   <Ctrl-f>      : 補完ドキュメントを下にスクロール
  --   <Ctrl-Space>  : 補完を手動でトリガー
  --   <Ctrl-e>      : 補完をキャンセル
  --   <Enter>       : 選択した補完を確定
  local cmp = require'cmp'

  cmp.setup({
    snippet = {
      expand = function(args)
        vim.fn["UltiSnips#Anon"](args.body)
      end,
    },
    window = {
      -- completion = cmp.config.window.bordered(),
      -- documentation = cmp.config.window.bordered(),
    },
    mapping = cmp.mapping.preset.insert({
      ['<C-b>'] = cmp.mapping.scroll_docs(-4),
      ['<C-f>'] = cmp.mapping.scroll_docs(4),
      ['<C-Space>'] = cmp.mapping.complete(),
      ['<C-e>'] = cmp.mapping.abort(),
      ['<CR>'] = cmp.mapping.confirm({ select = true }),
    }),
    sources = cmp.config.sources({
      { name = "copilot" },
      { name = 'nvim_lsp' },
      { name = 'vsnip' },
    }, {
      { name = 'buffer' },
      { name = 'path' },
    })
  })

  -- ============================================
  -- LSPサーバー設定
  -- ============================================
  local nvim_lsp = require('lspconfig')
  local cmp_capabilities = require('cmp_nvim_lsp').default_capabilities()
  local servers = { 'bashls', 'eslint' }

  for _, lsp in ipairs(servers) do
    nvim_lsp[lsp].setup {
      on_attach = function(client, bufnr)
        capabilities = cmp_capabilities
        on_attach = on_attach
        -- documentHighlightをサポートしている場合のみハイライトを有効化
        if client.server_capabilities.documentHighlightProvider then
          vim.cmd [[
            set updatetime=500
            highlight LspReferenceText  cterm=underline ctermfg=1 ctermbg=8 gui=underline guifg=#A00000 guibg=#104040
            highlight LspReferenceRead  cterm=underline ctermfg=1 ctermbg=8 gui=underline guifg=#A00000 guibg=#104040
            highlight LspReferenceWrite cterm=underline ctermfg=1 ctermbg=8 gui=underline guifg=#A00000 guibg=#104040
            augroup lsp_document_highlight
              autocmd! * <buffer>
              autocmd CursorHold,CursorHoldI <buffer> lua vim.lsp.buf.document_highlight()
              autocmd CursorMoved,CursorMovedI <buffer> lua vim.lsp.buf.clear_references()
            augroup END
          ]]
        end
      end
    }
  end

  -- gopls (Go) 設定
  nvim_lsp.gopls.setup {
    cmd = { vim.fn.expand('~/go/{{ go_version }}/bin/gopls') },
    on_attach = function(client, bufnr)
      capabilities = cmp_capabilities
      on_attach = on_attach
      if client.server_capabilities.documentHighlightProvider then
        vim.cmd [[
          set updatetime=500
          highlight LspReferenceText  cterm=underline ctermfg=1 ctermbg=8 gui=underline guifg=#A00000 guibg=#104040
          highlight LspReferenceRead  cterm=underline ctermfg=1 ctermbg=8 gui=underline guifg=#A00000 guibg=#104040
          highlight LspReferenceWrite cterm=underline ctermfg=1 ctermbg=8 gui=underline guifg=#A00000 guibg=#104040
          augroup lsp_document_highlight
            autocmd! * <buffer>
            autocmd CursorHold,CursorHoldI <buffer> lua vim.lsp.buf.document_highlight()
            autocmd CursorMoved,CursorMovedI <buffer> lua vim.lsp.buf.clear_references()
          augroup END
        ]]
      end
      -- 保存時に自動フォーマット
      if client.server_capabilities.documentFormattingProvider then
        vim.api.nvim_buf_set_keymap(bufnr, 'n', '<leader>f', '<cmd>lua vim.lsp.buf.format()<CR>', { noremap = true, silent = true })
        vim.cmd([[
          augroup GoAutoFormat
            autocmd!
            autocmd BufWritePre *.go lua vim.lsp.buf.format({ async = false })
          augroup END
        ]])
      end
    end
  }

  -- pylsp (Python) 設定 - uvでインストールしたPythonを使用
  nvim_lsp.pylsp.setup {
    cmd = { vim.fn.expand('~/.local/bin/pylsp') },
    settings = {
      pylsp = {
        plugins = {
          jedi = {
            environment = vim.fn.expand('~/.local/bin/python3'),
          },
        },
      },
    },
    on_attach = function(client, bufnr)
      capabilities = cmp_capabilities
      on_attach = on_attach
      if client.server_capabilities.documentHighlightProvider then
        vim.cmd [[
          set updatetime=500
          highlight LspReferenceText  cterm=underline ctermfg=1 ctermbg=8 gui=underline guifg=#A00000 guibg=#104040
          highlight LspReferenceRead  cterm=underline ctermfg=1 ctermbg=8 gui=underline guifg=#A00000 guibg=#104040
          highlight LspReferenceWrite cterm=underline ctermfg=1 ctermbg=8 gui=underline guifg=#A00000 guibg=#104040
          augroup lsp_document_highlight
            autocmd! * <buffer>
            autocmd CursorHold,CursorHoldI <buffer> lua vim.lsp.buf.document_highlight()
            autocmd CursorMoved,CursorMovedI <buffer> lua vim.lsp.buf.clear_references()
          augroup END
        ]]
      end
    end
  }

  -- Solargraph (Ruby) 設定
  nvim_lsp.solargraph.setup {
    cmd = { vim.fn.expand('~/.rbenv/versions/{{ ruby_version }}/bin/solargraph'), 'stdio' },
    on_attach = function(client, bufnr)
      capabilities = cmp_capabilities
      on_attach = on_attach
      -- documentHighlightをサポートしている場合のみハイライトを有効化
      if client.server_capabilities.documentHighlightProvider then
        vim.cmd [[
          set updatetime=500
          highlight LspReferenceText  cterm=underline ctermfg=1 ctermbg=8 gui=underline guifg=#A00000 guibg=#104040
          highlight LspReferenceRead  cterm=underline ctermfg=1 ctermbg=8 gui=underline guifg=#A00000 guibg=#104040
          highlight LspReferenceWrite cterm=underline ctermfg=1 ctermbg=8 gui=underline guifg=#A00000 guibg=#104040
          augroup lsp_document_highlight
            autocmd! * <buffer>
            autocmd CursorHold,CursorHoldI <buffer> lua vim.lsp.buf.document_highlight()
            autocmd CursorMoved,CursorMovedI <buffer> lua vim.lsp.buf.clear_references()
          augroup END
        ]]
      end
    end
  }

  -- sqls (SQL) 設定
  nvim_lsp.sqls.setup{
    on_attach = function(client, bufnr)
      capabilities = capabilities
      local status_ok, sqls = pcall(require, 'sqls')
      if status_ok then
        sqls.on_attach(client, bufnr)
      end
    end
  }

  -- ============================================
  -- Copilot 設定
  -- ============================================
  require("copilot").setup({
    suggestion = { enabled = false },
    panel = { enabled = false },
  })

  -- ============================================
  -- Claude Code 設定
  -- ============================================
  -- 使い方:
  --   <Ctrl-,>        : Claude Codeをトグル（ノーマルモード/ターミナルモード）
  --   <leader>cC      : Claude Code --continue で再開
  --   <leader>cV      : Claude Code --verbose で起動
  --   <Ctrl-h/j/k/l>  : ウィンドウ間の移動
  --   <Ctrl-f/b>      : ページアップ/ダウン
  local status_ok, claude_code = pcall(require, "claude-code")
  if status_ok then
    claude_code.setup({
      window = {
        split_ratio = 1.0,
        position = "botright",
        enter_insert = false,
        start_in_normal_mode = true,
        hide_numbers = true,
        hide_signcolumn = true,
      },
      refresh = {
        enable = true,
        updatetime = 100,
        timer_interval = 1000,
        show_notifications = true,
      },
      git = {
        use_git_root = true,
      },
      command = "claude",
      command_variants = {
        continue = "--continue",
        resume = "--resume",
        verbose = "--verbose",
      },
      keymaps = {
        toggle = {
          normal = "<C-,>",
          terminal = "<C-,>",
          variants = {
            continue = "<leader>cC",
            verbose = "<leader>cV",
          },
        },
        window_navigation = true,
        scrolling = true,
      }
    })
  end

  -- ============================================
  -- Go言語専用設定
  -- ============================================
  -- goimports: import文を自動整理する関数
  function goimports(timeout_ms)
    local context = { only = { "source.organizeImports" } }
    vim.validate { context = { context, "t", true } }

    local params = vim.lsp.util.make_range_params()
    params.context = context

    local result = vim.lsp.buf_request_sync(0, "textDocument/codeAction", params, timeout_ms)
    if not result or next(result) == nil then return end
    local actions = result[1].result
    if not actions then return end
    local action = actions[1]

    if action.edit or type(action.command) == "table" then
      if action.edit then
        vim.lsp.util.apply_workspace_edit(action.edit)
      end
      if type(action.command) == "table" then
        vim.lsp.buf.execute_command(action.command)
      end
    else
      vim.lsp.buf.execute_command(action)
    end
  end
EOF

" ============================================
" Go言語固有のキーマップと自動コマンド
" ============================================
" 使い方:
"   <Ctrl-o>        : 定義へジャンプ（Goファイル用）
"   保存時に自動実行:
"     - gofmt でフォーマット
"     - goimports でimport整理
nnoremap <C-o> :<C-u>lua vim.lsp.buf.definition()<CR>
autocmd BufWritePre *.go call execute('lua vim.lsp.buf.formatting_sync()')
autocmd BufWritePre *.go lua goimports(1000)

" ============================================
" 基本的なキーバインド
" ============================================
" 使い方:
"   j / k           : 表示行単位で上下移動（折り返し対応）
"   <Ctrl-h/j/k/l>  : ウィンドウ間を移動
nnoremap j gj
nnoremap k gk
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" ============================================
" インデント関連の設定
" ============================================
set tabstop=8          " タブ文字の表示幅
set softtabstop=4      " タブキー押下時の挿入幅
set shiftwidth=4       " 自動インデントの幅
set expandtab          " タブをスペースに展開
set smarttab           " 行頭でのタブ挿入を賢く
set autoindent         " 自動インデント
set backspace=indent,eol,start  " バックスペースの挙動

" ============================================
" 見た目・表示設定
" ============================================
set number             " 行番号を表示
set splitright         " 新しいウィンドウを右に開く
set hls                " 検索結果をハイライト
set whichwrap=b,s,h,l,<,>,[,]  " カーソルの左右移動で行をまたぐ
set cursorline         " カーソル行をハイライト
set cursorcolumn       " カーソル列をハイライト
set clipboard+=unnamedplus  " システムクリップボードと連携
set clipboard+=unnamed
set switchbuf+=usetab,newtab  " バッファ切り替え時にタブを使う
set wildignore=assets  " assetsディレクトリを補完候補から除外
set list               " 不可視文字を表示
set listchars=tab:»-,trail:-,eol:↲,extends:»,precedes:«,nbsp:%  " 不可視文字の表示方法

" ============================================
" 前回開いた位置から再開
" ============================================
augroup vimrcEx
  au BufRead * if line("'\"") > 0 && line("'\"") <= line("$") |
  \ exe "normal g`\"" | endif
augroup END

" ============================================
" WSL用設定 - クリップボード連携
" ============================================
if system('uname -a | grep microsoft') != ''
  augroup Yank
    au!
    autocmd TextYankPost * :call system('win32yank.exe -i', @")
  augroup END
  noremap <silent> p :call setreg('"',system('win32yank.exe -o'))<CR>""p
endif

" ============================================
" 起動時の自動設定
" ============================================
" 引数なしで起動した場合に自動でタブを開く
augroup StartupTabs
  au!
  autocmd VimEnter * nested call timer_start(500, {-> s:startup_tabs()})
augroup END

function! s:startup_tabs()
  " 引数なしで起動したかどうかを判定
  " - ファイル引数がある場合は開かない (argc() > 0)
  " - コマンド引数(-c)がある場合は開かない
  " - git commit等で呼ばれた場合は開かない
  let l:should_open_tabs = argc() == 0 && !s:has_command_arg()

  " 引数なしの場合のみタブを開く
  if l:should_open_tabs
    " ClaudeCodeを起動（プラグインが完全に読み込まれるまで待つ）
    if exists(':ClaudeCode')
      ClaudeCode
    else
      " プラグインがまだロードされていない場合は、さらに待つ
      call timer_start(500, {-> s:retry_claude_toggle()})
    endif

    " 別タブでcommon.sqlを開く
    tabnew ~/.local/share/nvim/common.sql

    " さらに空の新規タブを開く
    tabnew

    " 最初のタブ（ClaudeCode）に戻る
    tabfirst
  endif
endfunction

" コマンド引数(-cなど)が指定されているかチェック
function! s:has_command_arg()
  for arg in v:argv
    if arg =~# '^-c' || arg =~# '^+' || arg =~# '^--cmd'
      return 1
    endif
  endfor
  return 0
endfunction

function! s:retry_claude_toggle()
  if exists(':ClaudeCode')
    tabfirst
    ClaudeCode
  endif
endfunction
